\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
%\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[dvips]{graphicx}
\usepackage{listings}
\usepackage{moreverb}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{array}
\usepackage[final]{pdfpages}
\usepackage{listings}
\usepackage{nth}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{multirow}
\usepackage{pdfpages}

\hypersetup{
	pdfauthor = {Henrik Sohlberg},
	pdftitle = {avalg12: project 2},
	pdfsubject = {DD2440},
	pdfkeywords = {TSP},
	pdfcreator = {LaTeX with hyperref package},
	pdfproducer = {latex}
}

\title{Project 2: Euclidean TSP}
\author{Henrik Sohlberg <\href{mailto:hsoh@kth.se}{hsoh@kth.se}> %
\and Mårten Pålsson <\href{mailto:mpals@kth.se}{mpals@kth.se}>}

\fancyhf{}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[C]{\thepage}

\begin{document}

\pagestyle{empty}
\maketitle
\thispagestyle{empty}
\clearpage
\pagestyle{empty}
\abstract
The subject of this report is the creation of a program that factorizes numbers into their constituent primes and also different ways of doing so. The requirements of our program was that it had 15 seconds to factorize 100 numbers up to 100 bits in length using at most 32 MB of memory. Our solution used a combination of several methods to factorize integers. During the project we tried a few different variations but for our final version we used Pollard's rho algorithm using Floyds Circle detection algorithm together with Trial Division and finding Perfect Powers.
What we discovered were that Pollard's rho is good for the factorization of integers with small prime factors and that the most important feature of a program of this type, besides the algorithm itself, is to be able to control how the limited execution time is spent.
\clearpage
\begin{center}
\section*{Statement Of Collaboration}
\end{center}
Both Henrik Sohlberg and Mårten Pålsson have participated equally in the process of finding a solution to the main problem of this project, how to factorize large numbers. Later in the process (the implementation phase) Mårten implemented the Trial Division method, Henrik implemented the Perfect Power and the Fermat's Factorization methods, while both wrote the code to the Pollard's rho method.\\\\
Both contributed to the content of the whole report. Mårten wrote the sections: Introduction, parts of Background, parts of Method, Results, Discussion, and Conclusion. Henrik wrote parts of the background and parts of the method. 
\clearpage

\tableofcontents
\clearpage
\pagestyle{fancy}
\setcounter{page}{1} % sets the current page number to 32 

\section{Introduction}
\label{introduction}
The purpose of this project is to investigate different methods, heuristics and algorithms for solving the Traveling Salesman Problem, which will from now on be known simple as TSP. TSP is a problem where you want to find the shortest possible tour between the nodes in a graph. Or as the extended title says, the shortest route between a number of cities for a traveling salesman. 
\subsection{Problem Statement}
\label{problem_statement}
As stated above the subject of this report is the creation of an agent that solves TSP, the NP-hard \cite{one} problem of a salesman traveling around the country visiting cities. The salesman must visit each city (node) once and the task is to find the optimal tour, a sequence of nodes, where the distance (the set of edges) is as small as possible. The scope of this project is solving 50 instances of at most 1000 nodes each. The time and memory limit for our solution are limited to at most 2 seconds and 32 MB respectively. 

\clearpage

\section{Background}
\label{background}
The fact that the optimization version of TSP belongs to the family of NP-hard problems, there are no efficient algorithms that finds the optimal solution to TSP-instances. However, there are several algorithms solving smaller TSP instances more or less successfully. This section discuss a handful algorithms used in our approach. 

\subsection{Nearest Neighbour}
\label{nearest_neighbour}
Nearest neighbour is a naive algorithm for finding a solution to TSP. It works by selecting a starting node and then drawing an edge between it and its closest neighbour that has not yet been selected. Then you repeat the process for the node that was chosen as its closest neighbour until all nodes have been visited. 
This solution is not very efficient as it has a worst case time complexity of $O(n^2)$ time, and it does not provide a very good solution. \cite{two}

\subsection{Greedy}
\label{greedy}
The Greedy algorithm is similar to Nearest Neighbour \ref{nearest_neighbour}, but instead of progressing from node to node, it chooses among edges. Initially, all the $N$ cities with paths to each other is a complete graph and a Hamiltonian cycle will represent the tour the greedy algorithm creates. The cycle is built up by selecting the shortest edge available, where  \emph{"...an edge is available if it is not yet in the tour and if adding it would not create a degree-3 vertex or a cycle of length less than $N$."} \cite{three} 

The time complexity is $O(N^2 \log{N})$, thus slower than nearest neighbour, but its worst case tour is better than NN.

\subsection{Local Optimization}
\label{local_optimization}
A tour constructed using the above algorithms is seldom very good and can be optimized by local optimization algorithms. This means splitting the problem into smaller components and evaluating them locally without comparing them to the rest of the problem.

\subsubsection{Two-Opt}
\label{two_opt}
In two-opt every pair of edges is evaluated to see if the tour can be made shorter by exchanging them while still maintaining a complete tour \cite{four}. What this means is that the edges are re-drawn between the four nodes and the product of the length of the resulting edges is compared to the product of the length of the original edges. If the resulting length is shorter, the edges are exchanged. This process is then reiterated until all different edge combinations have been tried and the shortest ones have been found. Since you iterate over every edge pair the worst time complexitity of two-opt is $O(n)\cdot O(n)$ which is $O(n^2)$.

\subsubsection{Three-Opt}
\label{three_opt}
Three-Opt works in much the same way as two-opt except that it compares all triples of edges instead of only pairs. Delete the three chosen edges and try to put them together in different ways and choose the one that has the shortest length. \cite{two}

\subsubsection{Tabu Search}
\label{tabu_search}
The problem with local searches like two and three opt is that they can find themselves in a local minimum. This means that they can reach a state where they cannot improve the tour any more but it may not be the overall shortest tour, i.e a local minimum. To break these local minimums, Tabu Search allows the algorithm to reach a worse solution from where it can produce an in the end better solution. \cite{five}

\section{Method}
\label{method}
For our best implementation we used a simple solution algorithm was used.  A nearest neighbour algorithm was used as a construction algorithm and then two opt was used together with tabu search to improve the initial guess. 

First of all a map was constructed by reading the node information from stdin and creating a vector of nodes from the input. This vector is then used to create our initial starting guess using a nearest neighbour algorithm. A precomputed matrix of distances is created on map creation so that the distances between nodes only need to be calculated once.


If the tour only consists of one node this node is simply printed and the program continues on to the next map to be solved.

This starting guess is then improved by reiterating Two-Opt six times. This number was chosen because after testing we found that Two-Opt usually reached a local-minimum after this amount of reiterations. The length of the current tour  and the tour itself is saved for later comparison.
The algorithm then enters into a static loop.:
First a swap identical to the swap used in Two and Three-Opt, only using randomly generated, is used to break any possible local minimum we might have found ourselves in. Then we reiterate Two-Opt six more times to find a new local minimum. If the new tour is shorter than the old one it is saved as the best tour otherwise we continue with the loop.
This cycle of performing random swaps and then reiterating Two-Opt is repeated 7 times.

These static loops are there to control the time spent on each map. When one map has been solved the result is printed and the program continues on to the next map.
\subsection{Pseudo code}
\label{pseudo}
In this section, we present our implementation in pseudo code.
%
\subsubsection*{Greedy Tour(Map)}
\begin{algorithmic}
\STATE $tour[0] \gets 0$
\STATE $used[0] \gets true$
\FOR{$i \gets 1 \to n-1$}
	\STATE $best \gets -1$
	\FOR{$j \gets 0 \to n-1$}
		\IF{$\neg used[j] \wedge \left( best = -1 \vee dist\left(tour[i-1],j\right) < dist\left(tour[i-1],best\right)\right)$}
			\STATE $best \gets j$
		\ENDIF
		\STATE $tour[i] \gets best$
		\STATE $used[best] \gets true$
	\ENDFOR
\ENDFOR
\RETURN $tour$
\end{algorithmic}
%
\subsubsection*{twoOpt(Tour T, Map map)}
\begin{algorithmic}
\FOR{each edge pair $x_1,x_2$ and $y_1,y_2$}
	\IF{$\left(distance\left(x_1,x_2\right) + distance \left(y_1,y_2\right)\right) > \left(distance\left(x_1,y_1\right) + distance\left(x_2,y_2\right)\right)$}
		\STATE $T \gets swap(x_2,y_1,T)$
	\ENDIF
\ENDFOR
\RETURN $T$
\end{algorithmic}
%
\subsubsection*{threeOpt(Tour T, Map map)}
\begin{algorithmic}
\FOR{each edge triple $x_1,x_2$ and $y_1,y_2$ and $z_1,z_2$}
	\IF{$\big(dist(x_1, x_2) + dist(y_1, y_2)  + dist(z_1, z_2)) > dist(x_1, z_1) + dist(y_2, x_2) +  dist(y_1, z_2)$}
		\STATE$T \gets swap(x_2, z_1, T)$
		\STATE$T \gets swap(x_2, y_1, T)$
	\ENDIF
	\IF{$dist(x_1, z_1) + dist( y_2, x_2) +  dist(y_1, z_2) > dist(x_1, y_2) + dist(z_1, y_1) + dist(x_2, z_2)$}
		\STATE $T\gets swap(x_2, z_1, T)$
		\STATE $T\gets swap(y_2, z_1, T)$
	\ENDIF
\ENDFOR
\RETURN $T$
\end{algorithmic}
%
\subsubsection*{Solve(Map map)}
\begin{algorithmic}
\STATE hej 
\end{algorithmic}

\section{Results}
\label{results}
Below are accounts of the changes in the submissions where mayor implementation changes were made during the course of this project, and the results of their Kattis submissions. If something is not described in one of the implementation accounts, it has remained as it was in the last implementation. All results are abbreviated to the nearest decimal point.
\subsection{First Implementation}
\label{res_1}
\textbf{Kattis submission ID}: 306422 \\
\textbf{Description}:  Our first implementation used a system timer of 14 seconds to make sure we did not fail because of time issues. We also had no perfect power check and we only used the primes found between $[0,1000]$ for our Trial Division. The initialization values $x$ and $y$ in PR were $= 2$ and $c =1$.\\\\
\textbf{Number solved}: 50\\
\textbf{CPU time used}: 13.80 seconds\\

\clearpage

\section{Discussion}
\label{discussion}

\clearpage

\section{Conclusion}
\label{conclusion}

\clearpage

% References
\begin{thebibliography}{9}

\bibitem{one} \textsl{Travelling Salesman Problem} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://en.wikipedia.org/wiki/Travelling_salesman_problem}

\bibitem{two} \textsl{Tour construction heuristics} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://www.csc.kth.se/utbildning/kth/kurser/DD2440/avalg07/algnotes.pdf}

\bibitem{three} David S. Johnson. Lyle A. McGeoch. The Traveling Salesman Problem: \textsl{A Case Study in Local Optimization} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://www2.research.att.com/~dsj/papers/TSPchapter.pdf}

\bibitem{four} \textsl{Improving Solutions} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://www-e.uni-magdeburg.de/mertens/TSP/node3.html}

\bibitem{five} \textsl{Tabu Search} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://mathworld.wolfram.com/TabuSearch.html}

\end{thebibliography}
\clearpage

\appendix
\section{Java implementation}
\lstset{
	language=[Visual]C++,
	keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	identifierstyle=\ttfamily,
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	showstringspaces=false,
	basicstyle=\small,
	numberstyle=\footnotesize,
	numbers=left,
	stepnumber=1,
	numbersep=10pt,
	tabsize=2,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	breakatwhitespace=false,
	aboveskip={1.5\baselineskip},
  columns=fixed,
  upquote=true,
  extendedchars=true,
% frame=single,
% backgroundcolor=\color{lbcolor},
}
%\lstinputlisting{pollard_roh.cpp}
\end{document}
