\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
%\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[dvips]{graphicx}
\usepackage{listings}
\usepackage{moreverb}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{array}
\usepackage[final]{pdfpages}
\usepackage{listings}
\usepackage{nth}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{multirow}
\usepackage{pdfpages}

\hypersetup{
	pdfauthor = {Henrik Sohlberg},
	pdftitle = {avalg12: project 2},
	pdfsubject = {DD2440},
	pdfkeywords = {TSP},
	pdfcreator = {LaTeX with hyperref package},
	pdfproducer = {latex}
}

\title{Project 2: Euclidean TSP}
\author{Henrik Sohlberg <\href{mailto:hsoh@kth.se}{hsoh@kth.se}> %
\and Mårten Pålsson <\href{mailto:mpals@kth.se}{mpals@kth.se}>}

\fancyhf{}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[C]{\thepage}

\begin{document}

\pagestyle{empty}
\maketitle
\thispagestyle{empty}
\clearpage
\pagestyle{empty}
\abstract
The subject of this report is the creation of a program that factorizes numbers into their constituent primes and also different ways of doing so. The requirements of our program was that it had 15 seconds to factorize 100 numbers up to 100 bits in length using at most 32 MB of memory. Our solution used a combination of several methods to factorize integers. During the project we tried a few different variations but for our final version we used Pollard's rho algorithm using Floyds Circle detection algorithm together with Trial Division and finding Perfect Powers.
What we discovered were that Pollard's rho is good for the factorization of integers with small prime factors and that the most important feature of a program of this type, besides the algorithm itself, is to be able to control how the limited execution time is spent.
\clearpage
\begin{center}
\section*{Statement Of Collaboration}
\end{center}
Both Henrik Sohlberg and Mårten Pålsson have participated equally in the process of finding a solution to the main problem of this project, how to factorize large numbers. Later in the process (the implementation phase) Mårten implemented the Trial Division method, Henrik implemented the Perfect Power and the Fermat's Factorization methods, while both wrote the code to the Pollard's rho method.\\\\
Both contributed to the content of the whole report. Mårten wrote the sections: Introduction, parts of Background, parts of Method, Results, Discussion, and Conclusion. Henrik wrote parts of the background and parts of the method. 
\clearpage

\tableofcontents
\clearpage
\pagestyle{fancy}
\setcounter{page}{1} % sets the current page number to 32 

\section{Introduction}
\label{introduction}
The purpose of this project is to investigate different methods, heuristics and algorithms for solving the Traveling Salesman Problem, which will from now on be known simple as TSP. TSP is a problem where you want to find the shortest possible tour between the nodes in a graph. Or as the extended title says, the shortest route between a number of cities for a traveling salesman. 
\subsection{Problem Statement}
\label{problem_statement}
As stated above the subject of this report is the creation of an agent that solves TSP, the NP-hard\cite{one} problem of a salesman traveling around the country visiting cities. The salesman must visit each city (node) once and the task is to find the optimal tour, a sequence of nodes, where the distance (the set of edges) is as small as possible. The scope of this project is solving 50 instances of at most 1000 nodes each. The time and memory limit for our solution are limited to at most 2 seconds and 32 MB respectively. 

\clearpage

\section{Background}
\label{background}
The fact that the optimization version of TSP belongs to the family of NP-hard problems, there are no efficient algorithms that finds the optimal solution to TSP-instances. However, there are several algorithms solving smaller TSP instances more or less successfully. This section discuss a handful algorithms used in our approach. 

\subsection{Nearest Neighbour}
\label{nearest_neighbour}
Nearest neighbour is a naive algorithm for finding a solution to TSP. It works by selecting a starting node and then drawing an edge between it and its closest neighbour that has not yet been selected. Then you repeat the process for the node that was chosen as its closest neighbour until all nodes have been visited. 
This solution is not very efficient as it has a worst case time complexity of $O(n^2)$ time, and it does not provide a very good solution. \cite{two}

\subsection{Greedy}
\label{greedy}
The Greedy algorithm is similar to Nearest Neighbour \ref{nearest_neighbour}, but instead of progressing from node to node, it chooses among edges. Initially, all the $N$ cities with paths to each other is a complete graph and a Hamiltonian cycle will represent the tour the greedy algorithm creates. The cycle is built up by selecting the shortest edge available, where  \emph{"...an edge is available if it is not yet in the tour and if adding it would not create a degree-3 vertex or a cycle of length less than $N$."} \cite{three} 

The time complexity is $O(N^2 \log{N})$, thus slower than nearest neighbour, but its worst case tour is better than NN.

\subsection{Our Approach}
\label{our_approach}

\subsection{Pseudo code}
\label{pseudo}
\begin{algorithmic}
\STATE $Factorize$ $a$ $integer$ $N$
\STATE  
\STATE Initialize a vector $V$
\FOR{$i \gets 1 \to 100$}
	\STATE $N\gets$ input integer
	\STATE clear $V$
	\STATE $fail \gets false$
	\STATE $Factorize(N, 1)$
	\IF{$\neg{fail}$}
		\STATE Print all the elements in $V$
	\ENDIF
\ENDFOR
\RETURN
\end{algorithmic}

\section{Results}
\label{results}
Below are accounts of the changes in the submissions where mayor implementation changes were made during the course of this project, and the results of their Kattis submissions. If something is not described in one of the implementation accounts, it has remained as it was in the last implementation. All results are abbreviated to the nearest decimal point.
\subsection{First Implementation}
\label{res_1}
\textbf{Kattis submission ID}: 306422 \\
\textbf{Description}:  Our first implementation used a system timer of 14 seconds to make sure we did not fail because of time issues. We also had no perfect power check and we only used the primes found between $[0,1000]$ for our Trial Division. The initialization values $x$ and $y$ in PR were $= 2$ and $c =1$.\\\\
\textbf{Number solved}: 50\\
\textbf{CPU time used}: 13.80 seconds\\

\clearpage

\section{Discussion}
\label{discussion}

\clearpage

\section{Conclusion}
\label{conclusion}

\clearpage

% References
\begin{thebibliography}{9}

\bibitem{one} \textsl{Travelling Salesman Problem} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://en.wikipedia.org/wiki/Travelling_salesman_problem}

\bibitem{two} \textsl{Tour construction heuristics} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://www.csc.kth.se/utbildning/kth/kurser/DD2440/avalg07/algnotes.pdf}

\bibitem{three} David S. Johnson. Lyle A. McGeoch. The Traveling Salesman Problem: \textsl{A Case Study in Local Optimization} [Homepage on the Internet]. [cited 2012-12-05]. Available from: \url{http://www2.research.att.com/~dsj/papers/TSPchapter.pdf}

\end{thebibliography}
\clearpage

\appendix
\section{Java implementation}
\lstset{
	language=[Visual]C++,
	keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	identifierstyle=\ttfamily,
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	showstringspaces=false,
	basicstyle=\small,
	numberstyle=\footnotesize,
	numbers=left,
	stepnumber=1,
	numbersep=10pt,
	tabsize=2,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	breakatwhitespace=false,
	aboveskip={1.5\baselineskip},
  columns=fixed,
  upquote=true,
  extendedchars=true,
% frame=single,
% backgroundcolor=\color{lbcolor},
}
%\lstinputlisting{pollard_roh.cpp}
\end{document}
